########## 1> Routing :- it is the technique to move form one page to another page in webpages. 

routing in react and routing in next.js are different . 
we perform routing in react by the help of react-router-dom package inside Routes in app.jsx

but in next.js react router dom is inbuilt functionality where we perform routing simply in page.js
we need to make a componanent with same name as main file. hence routing is done in next.js 

for example :- we have main file named as page.js 
               if we want make a about section then first make about folder inside app and make page.js file inside about folder. and write your about content.

hence routing done in next.js  

Note :- your route name will be similar as your folder name like in abouve case /about your route as your folder name is about.

########## 2> nested routing :- Routing inside routing 
    
    To perform nested routing in next.js we have to perform the sme steps as we did to make a our route.

    for example :- inside 
                   /Project there are two more route /fuelfit and /food_paradise . to reach out to fuelfit we have to write our route /Project/fuelfit inside project folder in page.js

                   /Project ----> /Project/fuelfit ----> /Project/fuelfit/aboutfuelfit        it is the nexted routing.

########## 3> dynamic routing 
         
       
       it is routing that involves any route after / . it means in this we dont have to specified our route. we just use / ( anything name or string).

       to use dynamic route we have to make a folder name as [ with anyname ].

########## 4> next.js supportes both client side and server side renderring that's why we have to mention at the top of file either we are using client side renderring or server side renderring  

 and all the hooks comes under in client side renderring that's why we have to mention 'use client' before using any hooks in next.js
       
########## 5> API fetching in next.js 

   in sevrer component we can use async or it highly recommended to use fetch() function for fetching the data. because fetch() provide  all other functionality also rather than  fetching only in next.js
   
   const data = await fetch();
   const data1 = await data.json();

   basically it all done in server componanent

   but we can do this in client componanent with the help of use() hook and we dont need to use async or await 

   client componanent :- run two times one in server to get the data then in client (browser) that is called streaming the data from server to client.
   server componanent :- run only once in server to get the data.

######### 6> creating a api route in the next.js 

 like if we want a api route like this api/posts 
     then we have to make folder structure like this 
            
            first api folder then inside posts folder make route.js file.

######### 7> json placeholder :- collection of fake api for the testing and prototyping.

######### 8> always place a component folder inside src directory . not inside app directory.

######### 9> always takecare of folder structure and convention so that anyone can see and easily understand your code. 
             
          --> make a group of files which is in same page. like home page contain navbar , main banner , footer , feature section etc 

               so in home page there are main banner and feature section that are not in other pages. means main banner and feature section are only in homepage not in other page. so make component folder of all those file which is present in homepage. 

               (home) folder --> component folder --> Banner.jsx .
                                 component folder --> Feature.jsx   

              and make all this folder inside app directory. next.js will not consider round bracket () as a route.

          --> now navbar , footer is the files which are present in all page so make this group also outside the app directory but inside src directory.
              
              component folder --> Navbar.jsx .
              component folder --> Footer.jsx .

######### 10> whenever we get any situation where we have to use client component or server component both in single file . we always make a another file for the     client component tool and mount that component in old file so that website not disturbed and work properly. 

              suppose we have fetched the data from database in file A .this handled by server component now we want to use onclick property that is work under client component that means for using all click event we have to make a file as client component. Instead of making a file A as client component . we make another component file ( File B ) inside that we put that onlick function and mount this on file A. 

              Now File A work properly for server side and client side.

######### 11> component Streaming 

          component Streaming is a data transfer technique that allows you to break down a route into smaller "chunks" and progressively stream them from the server to the client as they become ready.

          By streaming, you can prevent slow data requests from blocking your whole page. This allows the user to see and interact with parts of the page without waiting for all the data to load before any UI can be shown to the user. this improve a UX ( user experience).

          for example suppose you made one webpage which consists navbar , feature section and footer. your webpage is not working due to slow data fetch from backend or api in feature section  so your whole page is not rendering either it has navbar or footer. 

          idealy the navabr and footer must show in webpage but due to that slow data fetch it is blocking itself. here component streaming work. 
          we just separate the feature section file from the navbar and footer . use Suspence here 

           <Navbar />

           <Suspence fallback="Loading....."> 
                 <FeatureSection />
           </Suspence> 

           <Footer />

           now if the data is slow still navbar and footer will not block and page render properly.

######### 12> caching 
           
          > caching means to store the data so that we can use in future efficiently . 
          > it reduce the server load where user request a same data from server . next.js store it by default so that user does not need to request the server again for the same data. 
          
          > there are four type of caching 
             - router caching (client)
             - full router caching (server)
             - data caching (server)
             - request memorization (server)

          > we can also remove or revalidate caching because sometime we need dynamic data with every request from server so there caching is not useful.
             - we can revalidate this by two method 

             1>Time-based Revalidation :- Revalidate data after a certain amount of time has passed and a new request is made. This is useful for data that changes infrequently.

                Revalidate at most every hour
                fetch('https://...', { 

                    next: { revalidate: 3600 in second }

                     })
                
                it means caching will be there for only 1 hour after 1 hour caching removed.

             2>On-demand Revalidation: Revalidate data based on an event (e.g. form submission). On-demand revalidation can use a tag-based or path-based approach to revalidate groups of data at once. This is useful when you want to ensure the latest data is shown as soon as possible 

                If you do not want to cache the response from fetch
                let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' }) 

          > Always use fetch() for fetching the data from database in next.js because next.js provide a excellent caching feature with fetch.




